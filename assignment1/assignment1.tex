\documentclass[journal,12pt,twocolumn]{IEEEtran}

\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}

\usepackage{amsthm}

\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}

\usepackage{longtable}
\usepackage{multirow}

\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{steinmetz}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage{tfrupee}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{tkz-euclide}

\usetikzlibrary{calc,math}
\usepackage{listings}
    \usepackage{color}                                            %%
    \usepackage{array}                                            %%
    \usepackage{longtable}                                        %%
    \usepackage{calc}                                             %%
    \usepackage{multirow}                                         %%
    \usepackage{hhline}                                           %%
    \usepackage{ifthen}                                           %%
    \usepackage{lscape}     
\usepackage{multicol}
\usepackage{chngcntr}

\DeclareMathOperator*{\Res}{Res}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
\begin{document}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}

\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\raggedbottom
\setlength{\parindent}{0pt}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
% \providecommand{\abs}[1]{\left\vert#1\right\vert}
% \providecommand{\res}[1]{\Res\displaylimits_{#1}} 
% \providecommand{\norm}[1]{\left\lVert#1\right\rVert}
% %\providecommand{\norm}[1]{\lVert#1\rVert}
% \providecommand{\mtx}[1]{\mathbf{#1}}
% \providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\numberwithin{equation}{subsection}
\makeatletter
\@addtoreset{figure}{problem}
\makeatother
\let\StandardTheFigure\thefigure
\let\vec\mathbf
\renewcommand{\thefigure}{\theproblem}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}
\vspace{3cm}
\title{Assignment 1}
\author{Krutik Mehta - EE18BTECH11027}
\maketitle
\newpage
\bigskip
\renewcommand{\thefigure}{\theenumi}
\renewcommand{\thetable}{\theenumi}
Download all latex-tikz codes from 
%
\begin{lstlisting}
https://github.com/Krutikmehta/C-and-DS/tree/master/assignment1
\end{lstlisting}
\section{Problem}
(CS-2020/CS/Q.NO:46) Consider the following C functions.
\begin{lstlisting}
int fun1(int n){
    static int i=0;
    if(n>0){
        i++;
        fun1(n-1);
    }
    return i;
}
\end{lstlisting}

\begin{lstlisting}
int fun2(int n){
    static int i=0;
    if(n>0){
        i += fun1(n);
        fun2(n-1);
    }
    return i;
}
\end{lstlisting}

Return the value of fun2(5) - 

\section{Solution}
Both the functions have static local variable. Static local variables have two characteristics  - 
\begin{enumerate}
    \item The scope of such variable is just within the function.
    \item The variable is not destroyed after function execution(it retains value). So, when function modifies the static local variable during the first function call, then this modified value will be available for the next function call also.
\end{enumerate}
\textbf{Explanation}
% \newline
fun1(n) returns the value of i(which has scope limited to fun1) after incrementing it by n.
\newline
fun2(n) calls fun1(i) from i=n to i=1 and adds the value returned by fun1 to i(which has scope limited to fun2).
\newline
when the first time fun1() is called for n=5, i is initialzed to 0. \\
The return value of each call is tabulated below.
\begin{center}
\begin{tabular}{ |c|c|c| } 
 \hline
fun1(5)  & i=i+5; & i = 5. \\
fun1(4)  & i=i+4; & i = 9. \\
fun1(3)  & i=i+3; & i = 12. \\
fun1(2)  & i=i+2; & i = 14. \\
fun1(1)  & i=i+1; & i = 15. \\
 \hline
\end{tabular}
\end{center}
All values returned by fun1() are added to static local variable i in fun2() - 
\newline
therefore ,
\newline
\begin{equation*}
i = 5+9+12+14+15 = 55.
\end{equation*}
Hence, ans = 55.

\section{Mathematical Formulation}
From the table we can derive fun1() as -
\begin{equation*}
fun1(n) = n 
\end{equation*}
\begin{equation*}
fun1(n-1) = (n-1) + fun1(n) = (n-1) + n 
\end{equation*}
\begin{equation*}
fun1(n-2) = (n-2) + fun1(n-1) = (n-2) + (n-1) + n
\end{equation*}

Therefore
\begin{equation*}
fun1(x) = \sum_{i=0}^{n-x} (n-i)
\end{equation*}

and since fun2() is the summation of fun1(x) from x=1 to n.\\
\begin{equation*}
fun2(n) = \sum_{j=1}^{n} \sum_{i=0}^{n-x} (n-i)
\end{equation*}
\begin{equation*}
fun2(n) = \sum_{j=1}^{n} \frac{1}{2}(n+j)(n-j+1)
\end{equation*}
\begin{equation*}
fun2(n) = \frac{1}{2} (\sum_{j=1}^{n} (n\textsuperscript{2} + n) + \sum_{j=1}^{n} (j - j\textsuperscript{2}) )
\end{equation*}
\begin{equation*}
fun2(n) = \frac{1}{6} (2n\textsuperscript{3} + 3n\textsuperscript{2} + n)
\end{equation*}


\section{Verification} 
For n = 5, the output of the c code was 55.\\
Using the mathematical formula -
\begin{equation*}
fun2(n) = \frac{1}{6} (2n\textsuperscript{3} + 3n\textsuperscript{2} + n)
\end{equation*}
\begin{equation*}
fun2(5) = \frac{1}{6} (2*5\textsuperscript{3} + 3*5\textsuperscript{2} + 5) \\
\end{equation*}
\begin{equation*}
fun2(5) = \frac{1}{6} (250 + 75 +5) \\
\end{equation*}
\begin{equation*}
fun2(5) = \frac{1}{6} 330 = 55.\\
\end{equation*}
Hence verified.
\end{document}
